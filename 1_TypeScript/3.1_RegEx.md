# Регулярные выражения:
## Модификаторы:
    'i' - Игнориорвание регистра 
    'g' - искать совпвдения много раз слева на право 
    'm' - Многострочный режим работы...?

## Символы:
    . - любой символ
    \ - экраниование
    ^ - первый символ
    $ - последний символ
    | - символ 'или'
        (:|;)|D - если не использовать скобки, то "ИЛИ" будет распространятся на всю строку
    () - групирующие скобки !автоматическое создание кармана
        (?:   ) - отменить создание кармана
        (?<letter>   ) - именованный карман
            \k<letter> - использование кармана по имени в самой регуларке

    \d      // любое число
        \D  // не число
    \w      // буква
        \W  // не буква
    \s      // probel
        \S  // не пробел
    \n      // перевд строки, не нужно экраниовать 
    \b      // обратиться границе слова
        \B  // не к границе

    [а-яё]  // КИРИЛИЦА
    [zy] // z или y
        [a-z] // один символ от a до z
            [:-@] //  группы получаются по таблице ASCII
        [a-z1-9] // один символ от a до z ИЛИ от 1 до 9
        [^ab] // Инверсия - один символ любой кроме a и b
        [abc.] // спецсимволы не нужно экранировать! Кроме  \d, \D, \w, \W, \s, \S

## КВАНТИФИКАТОРЫ:
    ? // 0 или 1
    + // 1 или много
    * // 0 или много
    {x, y} // от x до y (включительно)
        {5} // повторить 5 раз
        {2, } // от 2 раз
    *?, +?, *?, {x, y}? // Жадность
    
## Динамические регулярки в виде строк
    let x1 = 'png|jpg';
    let reg = new RegExp('^(' + x1 + ')$', 'gi');
    let reg = new RegExp('\\w+'); // ⛔исключение обратный слеш -> /\w+/

## Просмотр ВПЕРЕД
    'aaax aaab'.replace(/aaa(?=x)/g, '!'); // вернет '!x aaab'
    'aaax aaab'.replace(/aaa(?!x)/g, '!'); // вернет 'aaax !b'
## Просмотр НАЗАД
    'xaaa'.replace(/(?<=x)aaa/g, '!'); // вернет 'x!'
    'baaa'.replace(/(?<!x)aaa/g, '!'); // вернет 'b!'


# МЕТОДЫ 
# ==============================>


## .replace() -> return DIFFERENT NEW STRINGD
    let x = 'bab'.replace(/а/, '!'); // return 'b!b'

<!-- ⛔вырезаем части строки по одной проходя с лева на право строку каждый раз в цикле!⛔ -->
        let x1 = 'abababab'
        while(/a/g.test(x1)){
            x1 = x1.replace(/а/, '')
        }
        console.log(x1) // return 'bbbb'


<!-- ⛔Сначало находит все совпадения с лево на право - потом их вырезает разом, НЕ переобходит строку!⛔ -->
    ⛔let x1 = '2+3= 4+5= 6+7='.replace(/(\d+)\+(\d+)=/g, function(m0, m1, m2){
        let sum = Number(m1) + Number(m2); 
        return m0 + sum; 
    });
    
## test() -> return DIFFERENT NEW BOOLEAN
    let x1 = /Hello/g.test("Hello world!"); // return true

## ⛔match() -> return ARRAY | Null
    ⛔БЕЗ модификатора g метод возвращает массив, в нулевом элементе которого будет лежать найденная подстрока, а в остальных элементах - карманы. Если метод вызван с модификатором g он возвращает все найденные совпадения в виде массива.- https://code.mu/ru/javascript/manual/regular/match/
    let res = '12:34'.match(/(\d+):(\d+)/);
    console.log(res[0], res[1], res[2]); // '12:34' - найденное; '12' - первый карман; '34' - второй карман

search() -> return NUMBER INDEX
    возвращает позицию первой найденной подстроки, а если она не найдена - то -1.
    let str = 'a aa aaa aaaa aaaa';
    let res = str.search(/aaa/);

exec() -> return ARRAY | Null
    метод находит подстроки заданного шаблона в целевой строке и в результате возвращает массив с результатами, null – в противном случае. - https://code.mu/ru/javascript/book/supreme/regular/method-exec/
    lastIndex 

split(/../) -> retrun array


# КАРМАНЫ:
# ====================>
Для карманов не работает символ 'ИЛИ' - '|':
        /(.)\1|(.).\1/ - в этом случае обе переменных будут ссылатся на первый карман, нужно => /(.)\1|(.).\2/

## ИМЕНОВАННЫЕ КАРМАНЫ
    let str = '2025-10-29';
    let reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
    let res = str.match(reg);
        console.log(res.groups.year);  // 2025
        console.log(res.groups.month); // 10
        console.log(res.groups.day);   // 29


## КАРМАНЫ В САМОЙ РЕГУЛЯРКЕ 
    let x1 = 'aaasxa'.replace(/([a-z])\1*/g, '!'); // return  '!sxa'

### ИМЕНОВАННЫЕ КАРМАНЫ
    let res = str.replace(/(?<letter>[a-z])\k<letter>/g, '!');


    Карманы стандартные:
        console.log('e3rr8r'.replace(/\d/g, "$`($&)$'")); // $& - всё найденное совпадение, $` и $' - часть строки до и после совпадения

        let res = str.replace(/([a-z]+)@([a-z]+)/g, '$2@$1');

        'e3r'.replace(/\d/g, '($&)'); // стандартные карманы: $& - всё найденное совпадение, $` и $' - часть строки до и после совпадения. 
