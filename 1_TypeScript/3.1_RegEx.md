# Принцыпы работы:
    - Карманы: для карманок не работает символ 'ИЛИ' - '|':
        /(.)\1|(.).\1/ - в этом случае обе переменных будут ссылатся на первый карман, нужно => /(.)\1|(.).\2/



# МОДИФИКАТОРЫ:
    'i' - Игнориорвание регистра 
    'm' - Многострочный режим работы при котором ^ будет ловить начало каждой строки, а $ конец каждой строки
    'g' - искать совпвдения много раз ⛔НО в строке слева на право 

# Символы:
    .       // любой символ
    \d      // любое число
        \D  // не число
    \w      // буква
    [а-яё]  // КИРИЛИЦА
        \W  // не буква
    \s      // probel
        \S  // не пробел
    \n      // перевд строки, не нужно экраниовать 
    \b      // обратиться границе слова
        \B  // не к границе
    \ // экраниование
    ^ // первый символ
    $ // последний символ
    () // групирующие скобки - для применения н
    | // символ или
        /(:|;)(-|~)|D/ // если не использовать скобки, то "ИЛИ" будет распространятся на всю строку

    [zy] // z или y
        [a-z] // один символ от a до z
            [:-@] //  группы получаются по таблице ASCII
        [a-z1-9] // один символ от a до z ИЛИ от 1 до 9
        [^ab] // Инверсия - один символ любой кроме a и b
        [abc.] // спецсимволы внутри квадратных скобок становятся простыми - итх не нужно экранировать! Кроме  \d, \D, \w, \W, \s, \S
        /x[\[\]]x/ // 
# КВАНТИФИКАТОРЫ:
    ? // 0 или 1
        ?? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    + // 1 или много
        +? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    * // 0 или много
        *? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    {x, y} // повторение от x до y включительно
        {5} // повторить 5 раз
        {2, } // повторить 2 и более раз !!! { , 2} - не существует
        {x, y}? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    
# Динамические регулярки в виде строк
    https://code.mu/ru/javascript/book/supreme/regular/string/
    let pat = 'png|jpg';
    let reg = new RegExp('^(' + pat + ')$', 'gi'); // -> /^(png|jpg)$/gi
        let reg = new RegExp('\\w+'); // ⛔исключение обратный слеш -> /\w+/



# METHODS 
#### #############################################################################################
# replace() -> return STRING
    'bab'.replace(/а/, '!'); // return 'b!b'

    // Продвинутые карманы 
    let res = str.replace(/\d+/g, '($&)'); // стандартные карманы: $& - всё найденное совпадение, $` и $' - часть строки до и после совпадения. 
    
    // Стандартные карманы
    let res = str.replace(/([a-z]+)@([a-z]+)/g, '$2@$1');

    // CallBack
    let result = '2+3= 4+5= 6+7='.replace(/(\d+)\+(\d+)=/g, function(m0, m1, m2){
        let sum = Number(m1) + Number(m2); 
        return m0 + sum; 
    });

# test() -> return BOOLEAN
    let x1 = /Hello/g
    let result1 = x1.test("Hello world!") // return true

# ⛔match() -> return ARRAY | Null
    ⛔БЕЗ модификатора g метод возвращает массив, в нулевом элементе которого будет лежать найденная подстрока, а в остальных элементах - карманы. Если метод вызван с модификатором g он возвращает все найденные совпадения в виде массива.- https://code.mu/ru/javascript/manual/regular/match/
    let res = '12:34'.match(/(\d+):(\d+)/);
    console.log(res[0], res[1], res[2]); // '12:34' - найденное; '12' - первый карман; '34' - второй карман

search() -> return NUMBER INDEX
    возвращает позицию первой найденной подстроки, а если она не найдена - то -1.
    let str = 'a aa aaa aaaa aaaa';
    let res = str.search(/aaa/);

exec() -> return ARRAY | Null
    метод находит подстроки заданного шаблона в целевой строке и в результате возвращает массив с результатами, null – в противном случае. - https://code.mu/ru/javascript/book/supreme/regular/method-exec/
    lastIndex 



# КАРМАНЫ ##################################################################################################
// ИМЕНОВАННЫЕ КАРМАНЫ
    let str = '2025-10-29';
    let reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
    let res = str.match(reg);
        console.log(res.groups.year);  // 2025
        console.log(res.groups.month); // 10
        console.log(res.groups.day);   // 29


# КАРМАНЫ В САМОЙ РЕГУЛЯРКЕ 
// Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш. Например, первый карман будет доступен вот так: \1, второй карман вот так - \2, третий - \3 и так далее.

    let str = 'aaasxca'; // https://code.mu/ru/javascript/book/supreme/regular/expression-pockets/
    let res = str.replace(/([a-z])\1*/g, '!'); // return  '!sxca'

    // ИМЕНОВАННЫЕ КАРМАНЫ
    let res = str.replace(/(?<letter>[a-z])\k<letter>/g, '!');



// Просмотр ВПЕРЕД
    'aaax aaab'.replace(/aaa(?=x)/g, '!'); // вернет '!x aaab'
    'aaax aaab'.replace(/aaa(?!x)/g, '!'); // вернет 'aaax !b'
// Просмотр НАЗАД
    'xaaa'.replace(/(?<=x)aaa/g, '!'); // вернет 'x!'
    'baaa'.replace(/(?<!x)aaa/g, '!'); // вернет 'b!'