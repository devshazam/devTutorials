# Принцыпы работы:
# ===================================================================================================================================>
    - Карманы: для карманов не работает символ 'ИЛИ' - '|':
        /(.)\1|(.).\1/ - в этом случае обе переменных будут ссылатся на первый карман, нужно => /(.)\1|(.).\2/

## МОДИФИКАТОРЫ:
    'i' - Игнориорвание регистра 
    'm' - Многострочный режим работы при котором ^ будет ловить начало каждой строки, а $ конец каждой строки
    'g' - искать совпвдения много раз ⛔НО в строке слева на право 

## Символы:
    . - любой символ
    \ - экраниование
    ^ - первый символ
    $ - последний символ
    | - символ 'или'
        (:|;)|D - если не использовать скобки, то "ИЛИ" будет распространятся на всю строку
    () - групирующие скобки !автоматическое создание кармана
        (?:   ) - отменить создание кармана
        (?<letter>   ) - именованный карман
            \k<letter> - использование кармана по имени в самой регуларке
## Просмотр ВПЕРЕД
    'aaax aaab'.replace(/aaa(?=x)/g, '!'); // вернет '!x aaab'
    'aaax aaab'.replace(/aaa(?!x)/g, '!'); // вернет 'aaax !b'
## Просмотр НАЗАД
    'xaaa'.replace(/(?<=x)aaa/g, '!'); // вернет 'x!'
    'baaa'.replace(/(?<!x)aaa/g, '!'); // вернет 'b!'
  
    \d      // любое число
        \D  // не число
    \w      // буква
    [а-яё]  // КИРИЛИЦА
        \W  // не буква
    \s      // probel
        \S  // не пробел
    \n      // перевд строки, не нужно экраниовать 
    \b      // обратиться границе слова
        \B  // не к границе

    [zy] // z или y
        [a-z] // один символ от a до z
            [:-@] //  группы получаются по таблице ASCII
        [a-z1-9] // один символ от a до z ИЛИ от 1 до 9
        [^ab] // Инверсия - один символ любой кроме a и b
        [abc.] // спецсимволы внутри квадратных скобок становятся простыми - итх не нужно экранировать! Кроме  \d, \D, \w, \W, \s, \S
        /x[\[\]]x/ // 

## КВАНТИФИКАТОРЫ:
    ? // 0 или 1
        ?? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    + // 1 или много
        +? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    * // 0 или много
        *? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    {x, y} // повторение от x до y включительно
        {5} // повторить 5 раз
        {2, } // повторить 2 и более раз !!! { , 2} - не существует
        {x, y}? // (Жадность) - найти минимальную строку совпадения при возможности 'aba accca azzza wwwwa'
    
## Динамические регулярки в виде строк
    https://code.mu/ru/javascript/book/supreme/regular/string/
    let pat = 'png|jpg';
    let reg = new RegExp('^(' + pat + ')$', 'gi'); // -> /^(png|jpg)$/gi
        let reg = new RegExp('\\w+'); // ⛔исключение обратный слеш -> /\w+/


# МЕТОДЫ 
# =============================================================================================================================>


## .replace() -> return DIFFERENT NEW STRINGD

<!-- ⛔вырезаем части строки по одной проходя с лева на право строку каждый раз в цикле!⛔ -->
    let newString = 'bab'.replace(/а/, '!'); // 
        console.log(newString) // return 'b!b'
            ⚠️
                let x1 = 'abababab'
                while(/a/g.test(x1)){
                    x1 = x1.replace(/а/, '')
                }
                    console.log(x1) // return 'bbbb'
            ⚠️

<!-- ⛔Сначало находит все совпадения с лево на право - потом их вырезает разом, НЕ переобходит строку!⛔ -->
    ⛔let result = '2+3= 4+5= 6+7='.replace(/(\d+)\+(\d+)=/g, function(m0, m1, m2){
        let sum = Number(m1) + Number(m2); 
        return m0 + sum; 
    });
    
## test() -> return DIFFERENT NEW BOOLEAN
    let newBoolean = /Hello/g.test("Hello world!");
        console.log(newBoolean) // return true

## ⛔match() -> return ARRAY | Null
    ⛔БЕЗ модификатора g метод возвращает массив, в нулевом элементе которого будет лежать найденная подстрока, а в остальных элементах - карманы. Если метод вызван с модификатором g он возвращает все найденные совпадения в виде массива.- https://code.mu/ru/javascript/manual/regular/match/
    let res = '12:34'.match(/(\d+):(\d+)/);
    console.log(res[0], res[1], res[2]); // '12:34' - найденное; '12' - первый карман; '34' - второй карман

search() -> return NUMBER INDEX
    возвращает позицию первой найденной подстроки, а если она не найдена - то -1.
    let str = 'a aa aaa aaaa aaaa';
    let res = str.search(/aaa/);

exec() -> return ARRAY | Null
    метод находит подстроки заданного шаблона в целевой строке и в результате возвращает массив с результатами, null – в противном случае. - https://code.mu/ru/javascript/book/supreme/regular/method-exec/
    lastIndex 

split(/../) -> retrun array


# КАРМАНЫ:
# =============================================================================================================================>
// ИМЕНОВАННЫЕ КАРМАНЫ
    let str = '2025-10-29';
    let reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
    let res = str.match(reg);
        console.log(res.groups.year);  // 2025
        console.log(res.groups.month); // 10
        console.log(res.groups.day);   // 29


## КАРМАНЫ В САМОЙ РЕГУЛЯРКЕ 
// Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш. Например, первый карман будет доступен вот так: \1, второй карман вот так - \2, третий - \3 и так далее.

    let str = 'aaasxca'; // https://code.mu/ru/javascript/book/supreme/regular/expression-pockets/
    let res = str.replace(/([a-z])\1*/g, '!'); // return  '!sxca'

    // ИМЕНОВАННЫЕ КАРМАНЫ
    let res = str.replace(/(?<letter>[a-z])\k<letter>/g, '!');


    Карманы стандартные:
        console.log('e3rr8r'.replace(/\d/g, "$`($&)$'")); // $& - всё найденное совпадение, $` и $' - часть строки до и после совпадения
    let res = str.replace(/([a-z]+)@([a-z]+)/g, '$2@$1');
    'e3r'.replace(/\d/g, '($&)'); // стандартные карманы: $& - всё найденное совпадение, $` и $' - часть строки до и после совпадения. 
